package Моя;

public class Content {

    /** lesson_01  (22.12.22)
     * Знакомство с git
     * IDEA - знакомство
     * знакомство с примитивными типами данных



    lesson_02  (26.12.22)
     * Как работает git - ветки, загрузка
     * массивы
     * Создание класса



    lesson_03  (29.12.22)
     * Примитивные типы данных
     * Классы с их конструкторами и методами
     * Static

   lesson_04  (09.01.23)
     * Циклы
     * Арифметические операторы
     * Рекурсия
     * Разбор домашнего задания Морской бой


     lesson_05  (12.01.23)
     * Модификаторы доступа и наследование


     lesson_06  (16.01.23)
     * Принципы ООП:
       1. Инкапсуляция - область видимости, реализованная через модификаторы доступа:
                     * Public - чаще всего используемый модификатор. Поля и методы будут доступны во всех классах и пакетах проекта;
                     * Protected - доступен внутри пакета и у наследников данного класса независимо в каком пакете использовать;
                     * default - если ничего не указываем перед параметром или методом, то реализуется по умолчанию этот модификатор, который даёт доступ внутри данного пакета;
                     * Private - самый закрытый модификатор. Даёт доступ только внутри класса. К полям с этим модификатором мы можем создать доступ через Getter (получение данных) и Setter (изменение данных).
        Все переопределённые параметры могут быть либо с таким же модификатором, либо с модификатором имеющим более широкий доступ (например из Protected в Public).
     2. Абстракция - когда мы используем простые вещи, при описани чего-то сложного или хотим выделить главные, наиболее значиме характеристии предмета.
         Примером абстракции например являются String методы, которые мы спользуем повсеместно, а "под копотом" находится более сложная структура решения.
         Абстрактные классы впитали в себя свойства обычных классов и интерфейсов. Например мы можем создать в таком классе обычаный метод и
         метод который будут обязаны реализовать у себя дочерние классы от данного
     3. Наследование - это механизм, который позволяет создавать классы (дочерние) на основе  других классов (материнских).
             Дочерний класс через extends, наследует поля, конструкторы и метoды материнского класса,
        а так же имеет возможность переопределять их под свои особенности. Например метод say у класса animal "животное говорит"
        унаследует собака, но метод say будет выводить "собака говорит гав".
     4. Полиморфизм - это способность использовать свойства одного объекта использовать для описания другого.
        Например метыды с одинаковым названием, но разными параметрами (называется перегрузка метода).
        Также переопределение материнского метода является полиморфизмом.
        Также присвоение параметров ката общему животному Animal animal = new Cat ();
     * Интерфейсы - переобразование и наследование

     lesson_07  (19.01.23)
     - Абстрактные классы и интерфейсы, восходящее/нисходящее преобразование
      * Интерфейс - это некий класси-инструкция несущий в себе методы обязательные для исполнения наследуемыми классами.
        - Наследоваться интерфейс может несколько раз.
        - У интерфейсов нельзя создавать конструкторы или объекты
        - Параметры интерфейсов уже внутри java  являются static final.
        - Методы static необходимо реализовывать сразу.
        - Можно создавать default метод, который необязателен к реализации наследуемыми методами.
      * Абстрактные классы впитали в себя свойства обычных классов и интерфейсов. Так в нем можно создавать параметры и методы как в обычаном классе, и
     так же можем сождать метод который будут обязаны реализовать у себя дочерние классы от данного как в интерфейсе.
        - При наследовании от абстрактного, класс идёт с extends, а не с implement.
     * ENUM - это класс созданный для типизации данных. Он представляет собой некий более строгий массив. Их удобно структурировать.
        - ENUM всегда static, его невозможно унаследовать, создать абстрактные методы и создать локальные переменные;
        - switch всегда создают через ENUM

     lesson_08  (23.01.23)
      - Исключения - Exception;
        Checked (проверяемые) - которые компелятор требует обработать
        Unchecked (непроверяемые) - которые могут произойти, но это не точно.
            Такие ошибки обрабатывать для JAVA не обязательно. Но с точки зрения разработки нужно.
            Обработка ошибки производится через try catch. Где в try мы записываем часть кода в котором может произойти ошибка,
            а в catch обрабатываем саму ошибку, если она всё таки произошла в блоке кода записанном в  try.
            И тогда программа не упадёт и предложит варианты, проверяя этот блок кода.
            Так же мы можем проверить код на вероятность возникновения нескольких ошибок. Для этого в try с помощью
            команды throw new (вызываемая ошибка например RuntimeException), которая принудительно вызывает ошибку, мы прописываем все ошибки
            которые могут возникнуть в данном куске кода и в catch обрабатываем каждую ошибку.
            Действия на описанную в catch ошибку так же распространяются и на её наследников, поэтому при обработке кода нужну не забывать
            про иерархию ( сначала обрабатываем самую низшую в иерархии ошибку, потом двигаемся выше).
            Так же мы можем сождавать свои ошибки, не прописанные в Java. Например: наша программа обращается к нескольким источника
            и в одном из источников произошла ошибка. Мы создадим ошибку указывающую нам на тот источни с ошибкой.
            finally - необязательная команда которая выполнится независимо от того есть ошибка или нет (служит для закрытия файла или сети)


     lesson_09  (26.01.23)
     - Потоки IO и NIO
      Рассмотрим на примере открытия пользователем файла. Когда пользоатель открывает файл,
      между ним и файлом создаётся канал, по которому поступает поток данных.
      При работе с пакетом IO (приставка Stream) с этим открытым файлом может работать только один пользователь. Второй
         пользователь сможет открыть этот файл только после того как его закроет первый.
     При работе с пакетом NIO (приставка BUFFER) с этим файлом могут работать несколько поьзователей, так как канал состоит из буферов
     через которые поступают данные и файл при этом остаётся свободным к доступу другим пользователям.
     Потокам необходимо указывать рамки в пределах которых они должны работать или закрывать их с помощью flush или close.
     У любого потока должно быть место соединения (куда писать или откуда считывать)

     lesson_10  (30.01.23)


     */
}
